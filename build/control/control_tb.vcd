$date
	Sat May 29 15:41:54 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module control_tb $end
$var wire 8 ! stage2_instruction_out [7:0] $end
$var wire 16 " stage2_controls_out [15:0] $end
$var wire 8 # stage1_instruction_out [7:0] $end
$var wire 16 $ stage1_controls_out [15:0] $end
$var reg 1 % bus_request $end
$var reg 1 & clk $end
$var reg 1 ' fetch_suppress $end
$var reg 1 ( flag_acarry $end
$var reg 1 ) flag_lcarry $end
$var reg 1 * flag_overflow $end
$var reg 1 + flag_pcraflip $end
$var reg 1 , flag_reset $end
$var reg 1 - flag_sign $end
$var reg 1 . flag_zero $end
$var reg 8 / instruction [7:0] $end
$scope module pipeline_stage1_1 $end
$var wire 1 % bus_request $end
$var wire 1 & clk $end
$var wire 16 0 controls_out [15:0] $end
$var wire 1 ' fetch_suppress $end
$var wire 1 ( flag_acarry $end
$var wire 1 ) flag_lcarry $end
$var wire 1 * flag_overflow $end
$var wire 1 + flag_pcraflip $end
$var wire 1 , flag_reset $end
$var wire 1 - flag_sign $end
$var wire 1 . flag_zero $end
$var wire 8 1 instruction [7:0] $end
$var wire 4 2 xferload_select [3:0] $end
$var wire 3 3 xferassert_select [2:0] $end
$var wire 2 4 rhs_select [1:0] $end
$var wire 2 5 lhs_select [1:0] $end
$var wire 8 6 instruction_out [7:0] $end
$var wire 1 7 fetch_suppress_out $end
$var wire 4 8 aluop_select [3:0] $end
$var wire 16 9 addr [15:0] $end
$var reg 16 : controls [15:0] $end
$var reg 8 ; prev_instruction [7:0] $end
$upscope $end
$scope module pipeline_stage2_1 $end
$var wire 1 < bus_request $end
$var wire 1 & clk $end
$var wire 16 = controls_out [15:0] $end
$var wire 1 > fetch_suppress $end
$var wire 1 ( flag_acarry $end
$var wire 1 ) flag_lcarry $end
$var wire 1 * flag_overflow $end
$var wire 1 + flag_pcraflip $end
$var wire 1 , flag_reset $end
$var wire 1 - flag_sign $end
$var wire 1 . flag_zero $end
$var wire 8 ? instruction [7:0] $end
$var wire 8 @ instruction_out [7:0] $end
$var wire 2 A spsidi_inc_select [1:0] $end
$var wire 1 B pcra_flip_out $end
$var wire 4 C mainbus_load_select [3:0] $end
$var wire 4 D mainbus_assert_select [3:0] $end
$var wire 1 E bus_request_out $end
$var wire 1 F break_out $end
$var wire 3 G addr_select [2:0] $end
$var wire 16 H addr [15:0] $end
$var reg 16 I controls [15:0] $end
$var reg 8 J prev_instruction [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 J
b0 I
b0 H
b0 G
0F
0E
b0 D
b0 C
0B
b0 A
b0 @
b0 ?
z>
b0 =
z<
b0 ;
b0 :
b0 9
b0 8
07
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
0.
0-
0,
0+
0*
0)
0(
1'
0&
1%
b0 $
b0 #
b0 "
b0 !
$end
#1000
b1 G
b10000000000 "
b10000000000 =
b10000000000 I
1&
#2000
0&
#3000
1&
#4000
0&
#5000
1&
#6000
0&
#7000
1&
#8000
0&
#9000
1&
#10000
0&
b1101001 9
b1101001 /
b1101001 1
#11000
b1101001 H
b1101001 #
b1101001 6
b1101001 ?
b1101001 ;
1&
#12000
0&
b0 9
b0 /
b0 1
#13000
b0 H
b0 #
b0 6
b0 ?
b0 ;
b1101001 !
b1101001 @
b1101001 J
1&
#14000
0&
b10001000 9
b10001000 /
b10001000 1
#15000
b1 4
b11 8
b10001000 H
b10001000 #
b10001000 6
b10001000 ?
b0 !
b0 @
b0 J
b110100 $
b110100 0
b110100 :
b10001000 ;
1&
#16000
0&
#17000
b1000 D
b1 C
b10000011000 "
b10000011000 =
b10000011000 I
b10001000 !
b10001000 @
b10001000 J
1&
#18000
0&
b0 9
b0 /
b0 1
#19000
b0 4
b0 8
b0 H
b0 #
b0 6
b0 ?
b0 $
b0 0
b0 :
b0 ;
1&
#20000
0&
b100110 9
b100110 /
b100110 1
#21000
b110 2
b11 3
b100110 H
b100110 #
b100110 6
b100110 ?
b0 D
b0 C
b11011000000000 $
b11011000000000 0
b11011000000000 :
b100110 ;
b10000000000 "
b10000000000 =
b10000000000 I
b0 !
b0 @
b0 J
1&
#22000
0&
b0 9
b0 /
b0 1
#23000
b0 2
b0 3
b0 H
b0 #
b0 6
b0 ?
b100110 !
b100110 @
b100110 J
b0 $
b0 0
b0 :
b0 ;
1&
#24000
0&
#25000
b0 !
b0 @
b0 J
1&
#26000
0&
#27000
1&
#28000
0&
#29000
1&
#30000
0&
#31000
1&
#32000
0&
